<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | 法華経]]></title>
  <link href="http://namusyaka.github.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://namusyaka.github.com/"/>
  <updated>2012-10-02T17:39:13+09:00</updated>
  <id>http://namusyaka.github.com/</id>
  <author>
    <name><![CDATA[namusyaka]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby4Misawaをちょっと改良した件]]></title>
    <link href="http://namusyaka.github.com/blog/2012/10/02/github-jekyll/"/>
    <updated>2012-10-02T00:00:00+09:00</updated>
    <id>http://namusyaka.github.com/blog/2012/10/02/github-jekyll</id>
    <content type="html"><![CDATA[<p>以前公開したしょうもない作品の中にRuby4Misawaというものがある。
そうそうカテゴリなんか増えんだろうと思って、予めスクレイピングして取っておいたカテゴリ用Hashをソースに直書きしていたんだけど
久しぶりにミサワブログを見たらカテゴリが増えていた。
毎度こっちで対応するのも面倒なので、スクリプトを実行する度にカテゴリ用Hashを取得するようにした。
{% codeblock lang:ruby %}</p>

<h1>-<em>- encoding: UTF-8 -</em>-</h1>

<p>%w(
  uri
  open-uri
  kconv
  optparse
  rubygems
  nokogiri
).each { | name | require name }</p>

<p>class Misawa</p>

<p>  class NotFoundError &lt; ArgumentError; end;</p>

<p>  DOMAIN = 'http://jigokuno.com/'</p>

<p>  @@categories = {}</p>

<p>  Nokogiri.HTML(open(DOMAIN).read).css('dl').each do |dl|</p>

<pre><code>if dl.children[0].inner_html.toutf8 == '惚れさせ男子達'
  dl.children[2].children[1].children.to_a.delete_if{|node| node.class == Nokogiri::XML::Text}.each do |li|
    a = li.child
    @@categories[a.text.scan(/(.+?)(?:\([0-9]+\))?$/)[0][0]] = a[:href].scan(/cid=([0-9]+)/)[0][0]
  end
end
</code></pre>

<p>  end</p>

<p>  attr_reader :category, :page</p>

<p>  def initialize(category, page = 0)</p>

<pre><code>raise NotFoundError unless @@categories[category]
@category = @@categories[category]
@page = page =~ /^[0-9]+?\.\.[0-9]+?$/ ? eval(page) : page
</code></pre>

<p>  end</p>

<p>  def scrape</p>

<pre><code>create_uri.inject([]) do | result, uri |
  body = get_body(uri)
  Nokogiri.HTML(body).css('img.pict').map { | img | result &lt;&lt; img['src'] } if body
  result
end
</code></pre>

<p>  end</p>

<p>  class &lt;&lt; self;</p>

<pre><code>def save_misawa(category, page)
  misawa = self.new(category, page)
  misawa.scrape.each_with_index do | src, i |
    File.open("#{misawa.category}-#{i}.gif", 'w') { | f | f.write(misawa.get_body(src)) }
  end
end

def uri_misawa(category, page)
  misawa = self.new(category, page)
  misawa.scrape.each_with_index do | src, i |
    puts "#{misawa.category}-#{i} : #{src} "
  end
end

def method_missing(name, *args)
  raise ArgumentError;
end
</code></pre>

<p>  end</p>

<p>  def get_body(uri)</p>

<pre><code>open(URI.encode(uri)).read
</code></pre>

<p>  end</p>

<p>  def create_uri</p>

<pre><code>if @page.is_a?(Range)
  base = "#{DOMAIN}/?cid=#{@category}&amp;page="
  @page.map { | i | "#{base}#{i}" }
else
  ["#{DOMAIN}/?cid=#{@category}&amp;page=#{@page}"]
end
</code></pre>

<p>  end</p>

<p>end</p>

<p>if $0 === <strong>FILE</strong></p>

<p>  OptionParser.new do | opt |</p>

<pre><code>arguments = {}

opt.on('-t [TYPE]', '--type [TYPE]') do | value |
  arguments[:type] = value
end
opt.on('-p [PAGE]', '--page [PAGE]') do | value |
  arguments[:page] = value
end
opt.on('-c [CATEGORY]', '--category [CATEGORY]') do | value |
  arguments[:category] = value
end

opt.parse!(ARGV)
Misawa.send("#{arguments[:type] || 'uri'}_misawa", arguments[:category], arguments[:page])
</code></pre>

<p>  end</p>

<p>end
{% endcodeblock %}</p>

<p>前述した点以外にも、今までHTTPリクエスト時に例外捕捉していたところを消したりした。
今思えば、従来の通りに実装するとすればbeginとかendとか要らなかったなあ。
def hoge; rescue OpenURI::HTTPError; end;とか出来たわけで。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[チャベリ裏口に似たサービス「チャベリ勝手口」をつくった]]></title>
    <link href="http://namusyaka.github.com/blog/2012/08/29/github-jekyll/"/>
    <updated>2012-08-29T00:00:00+09:00</updated>
    <id>http://namusyaka.github.com/blog/2012/08/29/github-jekyll</id>
    <content type="html"><![CDATA[<p>手抜きなのであまり優れたユーザビリティとはいえないんですが公開します。
チャベリ裏口と違うのはch0.chaberi.comを取得するというところでしょうか。</p>

<p><a href="http://chaberi.namusyaka.info/">チャベリ勝手口α</a></p>

<p>個人サービスとはいえ、いい加減なんでもかんでも数時間で作っちゃおうとする癖直したいですね。
早く動くところがみたいという欲望が先行してクオリティもヘチマも無いようなことになります。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rubyで例外クラスを動的に定義する]]></title>
    <link href="http://namusyaka.github.com/blog/2012/03/18/github-jekyll/"/>
    <updated>2012-03-18T00:00:00+09:00</updated>
    <id>http://namusyaka.github.com/blog/2012/03/18/github-jekyll</id>
    <content type="html"><![CDATA[<p>グローバルの場合。
{% codeblock lang:ruby %}</p>

<p>Object.const_set('HogeError', Class.new(ArgumentError)) # 継承させたい例外クラスを渡す
raise HogeError</p>

<p>{% endcodeblock %}</p>

<p>Hoge::Fugaのようなネストされた空間の場合。
{% codeblock lang:ruby %}</p>

<p>module Hoge
  class Fuga</p>

<pre><code>self.const_set('Piyo', Class.new(ArgumentError))

def self.test; raise Piyo; end;
</code></pre>

<p>  end
end</p>

<p>Hoge::Fuga.test</p>

<p>{% endcodeblock %}</p>

<p>色々使い道があるかとは思いますが、例えば同じ例外クラスを継承する独自例外クラスを何個も定義する場合は以下のように書けて便利です。
{% codeblock lang:ruby %}</p>

<p>module Foo
  class Bar</p>

<pre><code>@@error_class = %w( Hoge Fuga Piyo )
@@error_class.each { |error| self.const_set(error, Class.new(ArgumentError)) }

# 例外を発生させるクラスメソッドを定義
class &lt;&lt; self
  @@error_class.each do |name|
    define_method name.downcase do
      raise self.const_get(name), "#{name} error !"
    end
  end
end
</code></pre>

<p>  end
end</p>

<p>Foo::Bar.hoge</p>

<p>{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[地獄のミサワ用スクレイピングライブラリをつくった]]></title>
    <link href="http://namusyaka.github.com/blog/2012/02/27/github-jekyll/"/>
    <updated>2012-02-27T00:00:00+09:00</updated>
    <id>http://namusyaka.github.com/blog/2012/02/27/github-jekyll</id>
    <content type="html"><![CDATA[<p>nokogiriとかoptparse使ってみたくてつくりまひた。
やたらと長いHashは、引数で受け取ったカテゴリが実在するかどうかをhttp-request飛ばして判断するようにすればなんとかなるとおもうけど、typo多そうだしやめておきまひた。
だけどカテゴリ増えるごとにコード修正すんのも面倒なんですよねー。
そのうち方針を変えるかもしれません。</p>

<p><a href="https://github.com/namusyaka/Ruby4Misawa">Ruby4Misawa/Github</a>
<a href="https://rubygems.org/gems/Ruby4Misawa">Ruby4Misawa/RubyGems</a></p>

<p>{% codeblock lang:ruby %}</p>

<h1>-<em>- encoding: UTF-8 -</em>-</h1>

<p>%w( uri open-uri optparse rubygems nokogiri ).each do | name |
  require name
end</p>

<p>class Misawa</p>

<p>  DOMAIN = 'http://jigokuno.com/'
  CATEGORIES = {</p>

<pre><code>"cecil" =&gt; 79,
"D-Matt" =&gt; 25,
"KAZ" =&gt; 1,
"KOUNOIKE" =&gt; 29,
"masa" =&gt; 13,
"masao" =&gt; 53,
"NAKAYAN" =&gt; 8,
"SYUN" =&gt; 24,
"ルシフェル" =&gt; 14,
"あつしさん" =&gt; 64,
"あの御方" =&gt; 37,
"しょうへい" =&gt; 66,
"すなお" =&gt; 38,
"たばっち" =&gt; 52,
"ちんちんでか男" =&gt; 57,
"つっちー" =&gt; 7,
"てづっちゃん" =&gt; 67,
"とりっぴー" =&gt; 82,
"なかじ" =&gt; 28,
"のぶちゃん" =&gt; 22,
"のぼる" =&gt; 49,
"のりすけ" =&gt; 21,
"はしもっさん" =&gt; 44,
"はまちゃん" =&gt; 55,
"ぴーなっつ" =&gt; 58,
"まみのパパ" =&gt; 56,
"りきお" =&gt; 85,
"エ～イチ" =&gt; 83,
"キヨシロー" =&gt; 17,
"キング" =&gt; 84,
"コウヘイ" =&gt; 3,
"シュナイダー" =&gt; 34,
"ショップ店員" =&gt; 12,
"ジーンズ" =&gt; 36,
"ジェイ" =&gt; 10,
"ソドム" =&gt; 78,
"タケ" =&gt; 54,
"チーポー" =&gt; 35,
"デスピサロ" =&gt; 46,
"ドリモグ" =&gt; 40,
"ナイト" =&gt; 50,
"ハリソン・フォード" =&gt; 41,
"バイトリーダー" =&gt; 71,
"ファイナルボム" =&gt; 74,
"フェイク" =&gt; 32,
"マイク" =&gt; 65,
"ミラージュ" =&gt; 5,
"ラッシュさん" =&gt; 19,
"リアル" =&gt; 81,
"リチャード" =&gt; 80,
"リュウー" =&gt; 26,
"レオン" =&gt; 59,
"吉岡" =&gt; 6,
"久志" =&gt; 51,
"玉木宏" =&gt; 43,
"健二" =&gt; 70,
"佐伯さん" =&gt; 76,
"砂漠の狼" =&gt; 63,
"坂本竜馬の子孫" =&gt; 27,
"桜井" =&gt; 39,
"時任" =&gt; 42,
"実行委員" =&gt; 47,
"小松っち" =&gt; 75,
"松尾" =&gt; 23,
"水谷" =&gt; 11,
"袖まくり" =&gt; 60,
"太陽 " =&gt; 68,
"代官山" =&gt; 33,
"大嶽一史" =&gt; 77,
"拓真" =&gt; 31,
"達也の兄ちゃん" =&gt; 72,
"痴漢" =&gt; 15,
"中村健" =&gt; 4,
"田部" =&gt; 20,
"東大生" =&gt; 45,
"湯上谷" =&gt; 16,
"藤井" =&gt; 9,
"道明寺" =&gt; 61,
"風雲児達" =&gt; 86,
"北岡" =&gt; 62,
"野村" =&gt; 2,
"野茂" =&gt; 30,
"零" =&gt; 69,
"零" =&gt; 73,
"和田" =&gt; 48
</code></pre>

<p>  }</p>

<p>  attr_reader :category, :page</p>

<p>  def initialize(category, page = 0)</p>

<pre><code>@category = CATEGORIES[category]
@page = page =~ /^[0-9]+?\.\.[0-9]+?$/ ? eval(page) : page
</code></pre>

<p>  end</p>

<p>  def scrape</p>

<pre><code>create_uri.inject([]) do | result, uri |
  body = get_body(uri)
  Nokogiri.HTML(body).css('img.pict').map { | img | result &lt;&lt; img['src'] } if body
  result
end
</code></pre>

<p>  end</p>

<p>  class &lt;&lt; self;</p>

<pre><code>def save_misawa(category, page)
  misawa = self.new(category, page)
  misawa.scrape.each_with_index do | src, i |
    File.open("#{misawa.category}-#{i}.gif", 'w') { | f | f.write(misawa.get_body(src)) }
  end
end

def uri_misawa(category, page)
  misawa = self.new(category, page)
  misawa.scrape.each_with_index do | src, i |
    puts "#{misawa.category}-#{i} : #{src} "
  end
end

def method_missing(name, *args)
  raise ArgumentError;
end
</code></pre>

<p>  end</p>

<p>  def get_body(uri)</p>

<pre><code>begin
  open(URI.encode(uri)).read
rescue OpenURI::HTTPError
  return nil
end
</code></pre>

<p>  end</p>

<p>  def create_uri</p>

<pre><code>if @page.is_a?(Range)
  base = "#{DOMAIN}/?cid=#{@category}&amp;page="
  @page.map { | i | "#{base}#{i}" }
else
  ["#{DOMAIN}/?cid=#{@category}&amp;page=#{@page}"]
end
</code></pre>

<p>  end</p>

<p>end</p>

<p>if $0 === <strong>FILE</strong></p>

<p>  OptionParser.new do | opt |</p>

<pre><code>arguments = {}

opt.on('-t [TYPE]', '--type [TYPE]') do | value |
  arguments[:type] = value
end
opt.on('-p [PAGE]', '--page [PAGE]') do | value |
  arguments[:page] = value
end
opt.on('-c [CATEGORY]', '--category [CATEGORY]') do | value |
  arguments[:category] = value
end

opt.parse!(ARGV)
Misawa.send("#{arguments[:type] || 'uri'}_misawa", arguments[:category], arguments[:page])
</code></pre>

<p>  end</p>

<p>end</p>

<p>{% endcodeblock %}</p>

<h2>使い方</h2>


<p>インストールは以下の通り。
{% codeblock lang:sh %}</p>

<p>gem install Ruby4Misawa</p>

<p>{% endcodeblock %}</p>

<p>以下は実行例。
ちなみにこれは、バイトリーダーの０～３ページまでに表示される画像を保存します。
{% codeblock lang:sh %}</p>

<p>ruby Ruby4Misawa.rb -t save -c バイトリーダー -p 0..3</p>

<p>{% endcodeblock %}</p>

<h5>簡単な解説(といってもREADMEの内容)</h5>


<dl>
<dt>-t [uri, save]
<dd>uriは画像のURIを出力、saveは保存しまくる。permission関係でこける可能性はありけり。
<dt>-c [カテゴリ名]
<dd>ルシフェル やバイトリーダーのように指定。一つしか指定できないので注意。
<dt>-p [対象ページ]
<dd>1 や 0のような数値か、0..5のようにRange形式で指定
<dd>&#8211;type, &#8211;category, &#8211;pageでも可
<dd>ちなみに何も指定しないと地獄のミサワのトップページにあるミサワ画像(と思われるもの)を取ってくる
</dl>


<p>良いミサワライフを！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RubyのデータをHTMLに変換]]></title>
    <link href="http://namusyaka.github.com/blog/2011/11/14/github-jekyll/"/>
    <updated>2011-11-14T00:00:00+09:00</updated>
    <id>http://namusyaka.github.com/blog/2011/11/14/github-jekyll</id>
    <content type="html"><![CDATA[<h2>data-converterってのをつくりました</h2>


<p>Hashをdl要素に、Arrayをul要素に、それ以外はto_sかまして文字列にします
gem install data-converterでインストールできます
<a href="https://github.com/namusyaka/data-converter">github</a>
<a href="https://rubygems.org/gems/data-converter">rubygems</a></p>

<p>例:
{% codeblock lang:ruby %}</p>

<p>require 'rubygems'
require 'data-converter'</p>

<p>puts DataConverter.parse({
  :a => "b",
  :c => { :d => ["&lt;>&amp;\"'", 1, 2] }
}) #=> &lt;&lt;-RESULT</p>

<dl>
<dt>a</dt>
<dd>b</dd>
<dt>c</dt>
<dd><dl>
<dt>d</dt>
<dd><ul>
<li>&lt;&gt;&amp;&quot;&#039;</li>
<li>1</li>
<li>2</li>
</ul>
</dd>
</dl>
</dd>
</dl>


<p>RESULT</p>

<p>{% endcodeblock %}</p>

<h2>はてなブログつくりました</h2>


<p><a href="http://namusyaka.hateblo.jp/">namusyakaぶろぐ</a>
技術系のこと以外ははてなブログを使おうと思います。</p>
]]></content>
  </entry>
  
</feed>
